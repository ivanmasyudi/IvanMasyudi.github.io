{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Selamat Datang di Repository Tugas \u00b6 Nama : Ivan Masyudi NIM : 180411100032 Jurusan : Teknik Informatika Matakuliah : Komputasi Numerik","title":"Beranda"},{"location":"#selamat-datang-di-repository-tugas","text":"Nama : Ivan Masyudi NIM : 180411100032 Jurusan : Teknik Informatika Matakuliah : Komputasi Numerik","title":"Selamat Datang di Repository Tugas"},{"location":"DERETMACLAURIN/","text":"DERET MACLAURIN \u00b6 Deret MacLaurin menyatakan bahwa setiap fungsi rill f(x) yang differentiable x = 0 dapat diuraikan menjadi deret polinomial: $$ f(x) = a0 + a1 x + a2x^2 + a3x^3 + ... $$ dengan $$ a_n = \\frac{1}{n!}f^n(0) $$ Dengan f^n(x) menyatakan turunan ke-n dari f(x). Notasi lain : f'(x) menyatakan turunan pertama, turunan f''(x) menyatakan turunan kedua, turunan f'''(x) menyatakan turunan ketiga, dst. Contoh: Uraikan f(x) = e^x dalam deret MacLaurin. Jawab: $$ f(x) = a0 + a1x + a2x^2 + a3x^3 + ... $$ a0, a1, a2, dst akan dicari satu per satu: Dengan demikian : $$ f(x) = ex = 1 + x + \\frac{1}{2!}x^2 + \\frac{1}{3!}x^3 +\u00b7\u00b7\u00b7 $$ PERHITUNGAN e^2x \u00b6 Dalam banyak masalah terapan, pilihan basis yang mudah digunakan adalah bilangan irasional e = 2,718281828... Bilangan ini disebut basis natural . Fungsi f ( x ) = ex disebut sebagai fungsi eksponensial natural. Gambar 7 menunjukkan grafik fungsi ini. Pastikan bahwa dalam melihat fungsi eksponensial f ( x ) = ex , e adalah konstanta 2,718281828\u2026, sedangkan x adalah variabel. f(x) = ex f'(x) = ex f'(0) = 1 f\u201d(x) = ex f\u201d(0) = 1 f\u201d'(x) = ex f\u201d'(0) = 1 Untuk bilangan e^2x maka: jadi, kesimpulannya adalah sebagai berikut: ketika nilai x diganti dengan 4 maka hasilnya adalah 296,99. LISTING PROGRAM \u00b6 Untuk membuat program agar dapat mengekspansi bilangan e^2x dengan nilai x=4 hingga nilai menjadi kurang dari 0,001 bisa dibuat dengan listing program sebagai berikut. import math x = 4 hasil = 1 a = 0 b = 1 iterasi = 1 while hasil > 0.001 : f_x = 0 f_y = 0 for i in range ( a ): f_x += int ( math . pow ( 2 , i )) * x ** i / math . factorial ( i ) for j in range ( b ): f_y += int ( math . pow ( 2 , j )) * x ** j / math . factorial ( j ) hasil = f_y - f_x a += 1 b += 1 print ( \"iterasi ke-\" , iterasi , \"= \" , hasil ) iterasi += 1 Output: iterasi ke - 1 = 1.0 iterasi ke - 2 = 8.0 iterasi ke - 3 = 32.0 iterasi ke - 4 = 85.33333333333333 iterasi ke - 5 = 170.66666666666669 iterasi ke - 6 = 273.0666666666666 iterasi ke - 7 = 364.08888888888896 iterasi ke - 8 = 416.1015873015872 iterasi ke - 9 = 416.1015873015872 iterasi ke - 10 = 369.8680776014112 iterasi ke - 11 = 295.89446208112895 iterasi ke - 12 = 215.195972422639 iterasi ke - 13 = 143.46398161509296 iterasi ke - 14 = 88.28552714774924 iterasi ke - 15 = 50.448872655856576 iterasi ke - 16 = 26.90606541645684 iterasi ke - 17 = 13.45303270822842 iterasi ke - 18 = 6.330838921519444 iterasi ke - 19 = 2.8137061873417224 iterasi ke - 20 = 1.184718394670199 iterasi ke - 21 = 0.47388735786807956 iterasi ke - 22 = 0.18052851728316455 iterasi ke - 23 = 0.06564673355751438 iterasi ke - 24 = 0.022833646454728296 iterasi ke - 25 = 0.0076112154847578495 iterasi ke - 26 = 0.0024355889549951826 iterasi ke - 27 = 0.0007494119863622473 Sekian dan terima kasih semoga bermanfaat. MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Tugas 1"},{"location":"DERETMACLAURIN/#deret-maclaurin","text":"Deret MacLaurin menyatakan bahwa setiap fungsi rill f(x) yang differentiable x = 0 dapat diuraikan menjadi deret polinomial: $$ f(x) = a0 + a1 x + a2x^2 + a3x^3 + ... $$ dengan $$ a_n = \\frac{1}{n!}f^n(0) $$ Dengan f^n(x) menyatakan turunan ke-n dari f(x). Notasi lain : f'(x) menyatakan turunan pertama, turunan f''(x) menyatakan turunan kedua, turunan f'''(x) menyatakan turunan ketiga, dst. Contoh: Uraikan f(x) = e^x dalam deret MacLaurin. Jawab: $$ f(x) = a0 + a1x + a2x^2 + a3x^3 + ... $$ a0, a1, a2, dst akan dicari satu per satu: Dengan demikian : $$ f(x) = ex = 1 + x + \\frac{1}{2!}x^2 + \\frac{1}{3!}x^3 +\u00b7\u00b7\u00b7 $$","title":"DERET MACLAURIN"},{"location":"DERETMACLAURIN/#perhitungan-e2x","text":"Dalam banyak masalah terapan, pilihan basis yang mudah digunakan adalah bilangan irasional e = 2,718281828... Bilangan ini disebut basis natural . Fungsi f ( x ) = ex disebut sebagai fungsi eksponensial natural. Gambar 7 menunjukkan grafik fungsi ini. Pastikan bahwa dalam melihat fungsi eksponensial f ( x ) = ex , e adalah konstanta 2,718281828\u2026, sedangkan x adalah variabel. f(x) = ex f'(x) = ex f'(0) = 1 f\u201d(x) = ex f\u201d(0) = 1 f\u201d'(x) = ex f\u201d'(0) = 1 Untuk bilangan e^2x maka: jadi, kesimpulannya adalah sebagai berikut: ketika nilai x diganti dengan 4 maka hasilnya adalah 296,99.","title":"PERHITUNGAN e^2x"},{"location":"DERETMACLAURIN/#listing-program","text":"Untuk membuat program agar dapat mengekspansi bilangan e^2x dengan nilai x=4 hingga nilai menjadi kurang dari 0,001 bisa dibuat dengan listing program sebagai berikut. import math x = 4 hasil = 1 a = 0 b = 1 iterasi = 1 while hasil > 0.001 : f_x = 0 f_y = 0 for i in range ( a ): f_x += int ( math . pow ( 2 , i )) * x ** i / math . factorial ( i ) for j in range ( b ): f_y += int ( math . pow ( 2 , j )) * x ** j / math . factorial ( j ) hasil = f_y - f_x a += 1 b += 1 print ( \"iterasi ke-\" , iterasi , \"= \" , hasil ) iterasi += 1 Output: iterasi ke - 1 = 1.0 iterasi ke - 2 = 8.0 iterasi ke - 3 = 32.0 iterasi ke - 4 = 85.33333333333333 iterasi ke - 5 = 170.66666666666669 iterasi ke - 6 = 273.0666666666666 iterasi ke - 7 = 364.08888888888896 iterasi ke - 8 = 416.1015873015872 iterasi ke - 9 = 416.1015873015872 iterasi ke - 10 = 369.8680776014112 iterasi ke - 11 = 295.89446208112895 iterasi ke - 12 = 215.195972422639 iterasi ke - 13 = 143.46398161509296 iterasi ke - 14 = 88.28552714774924 iterasi ke - 15 = 50.448872655856576 iterasi ke - 16 = 26.90606541645684 iterasi ke - 17 = 13.45303270822842 iterasi ke - 18 = 6.330838921519444 iterasi ke - 19 = 2.8137061873417224 iterasi ke - 20 = 1.184718394670199 iterasi ke - 21 = 0.47388735786807956 iterasi ke - 22 = 0.18052851728316455 iterasi ke - 23 = 0.06564673355751438 iterasi ke - 24 = 0.022833646454728296 iterasi ke - 25 = 0.0076112154847578495 iterasi ke - 26 = 0.0024355889549951826 iterasi ke - 27 = 0.0007494119863622473 Sekian dan terima kasih semoga bermanfaat. MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"LISTING PROGRAM"},{"location":"NewtonRapshon/","text":"Metode Newton Rapshon \u00b6 Metode Newtown Rapshon adalah pencarian root yang menggunakan pendekatan linier. Secara khusus, kami menebak solusi x_0 x_0 dari persamaan f(x)=0 f(x)=0 , menghitung perkiraan linier dari f(x) f(x) pada x_0 x_0 dan kemudian menemukan x x -intercept dari pendekatan linier . Rumus \u00b6 Biarkan f(x) f(x) menjadi fungsi yang dapat dibedakan. Jika x_0 x_0 mendekati solusi f(x)=0 f(x)=0 maka kita dapat memperkirakan f(x) f(x) dengan garis singgung pada x_0 x_0 dan menghitung x x -terima dari garis singgung. Persamaan garis singgung pada x_0 x_0 adalah y=f\u2032(x_0)(x\u2212x_0)+f(x_0) y=f\u2032(x_0)(x\u2212x_0)+f(x_0) x x -intercept adalah solusi x_1 x_1 dari persamaan 0=f\u2032(x_0)(x_1\u2212x_0)+f(x_0) 0=f\u2032(x_0)(x_1\u2212x_0)+f(x_0) dan kami menyelesaikannya dengan x_1 x_1 x1=x0\u2212 \\frac{f(x_0)}{f\u2032(x_0)} x1=x0\u2212 \\frac{f(x_0)}{f\u2032(x_0)} Jika kami menerapkan prosedur ini berulang kali, maka kami memperoleh urutan yang diberikan oleh rumus rekursif xn+1=xn\u2212 \\frac{f(x_n)}{f\u2032(x_n)} xn+1=xn\u2212 \\frac{f(x_n)}{f\u2032(x_n)} yang (berpotensi) konvergen ke solusi persamaan f(x)=0 f(x)=0 . Menyusun Algoritma dan Pemrograman Newton Rhapson \u00b6 dari rumus yang kita dapat diatas kita dapat menyusun sebuah algoritma yang nantinya akan dibuat menjadi sebuah program. Algoritma menyusun akar - akar f(x) = 0 f(x) = 0 sebagai berikut : Didefinisikan fungsi f f dengan f(x) f(x) dan f'(x) f'(x) Ditentukan Epsilon sebagai Toleransi kesalahan serta iterasi maksimum untuk Stopping Condition Dipilih tebakan awal x_0 x_0 Dihitung f(x_0) f(x_0) dan f'(x_0) f'(x_0) Dihitung x_b = x_0 - \\frac{f(x_0)}{f'(x_0)}f'(x_0) \\neq 0 x_b = x_0 - \\frac{f(x_0)}{f'(x_0)}f'(x_0) \\neq 0 . jika f'(x_0) = 0 f'(x_0) = 0 kembali ke langkah - 3 Jika \\left | x_b - x_0 \\right | < \\varepsilon \\left | x_b - x_0 \\right | < \\varepsilon . itersasi lebih dari iterasi maksimum tulis x_{hampiran} = x_b x_{hampiran} = x_b sebagai hasil hampiran akar; jika tidak, lanjutkan ke langkah berikutnya. Ganti nilai x_0 x_0 dengan x_0 = x_b x_0 = x_b dan kembali ke langkah-4 Listing Program \u00b6 #Program python untuk memperkirakan akar polinomial #menggunakan metode newton-raphson import math #f(x) - fungsi polynomial def f ( x ): function = ( x ** 3 ) - ( 2 * x ) - 1 return function def derivative ( x ): #berfungsi untuk menemukan turunan dari polinomial h = 0.000001 derivative = ( f ( x + h ) - f ( x )) / h return derivative def newton_raphson ( x ): return ( x - ( f ( x ) / derivative ( x ))) # p - titik awal mis. nilai lebih dekat ke root # n - jmulah iterasi def iterate ( p , n ): print ( \"Banyak Iterasinya =\" , n ) x = p for i in range ( n ): x = newton_raphson ( x ) print ( \"iterasi ke-\" , i , \"=\" , x ) return ( \"\" ) print ( iterate ( 1 , 10 )) #cetakan akar polinomial x ^ 3 - 2x - 1 menggunakan 3 iterasi dan ambil titik awal sebagai 1 Output Banyak Iterasinya = 10 iterasi ke - 0 = 2.999994000093219 iterasi ke - 1 = 2.199996832141079 iterasi ke - 2 = 1.7808294919560141 iterasi ke - 3 = 1.6363030634057565 iterasi ke - 4 = 1.618304588651506 iterasi ke - 5 = 1.6180340496697716 iterasi ke - 6 = 1.6180339887499484 iterasi ke - 7 = 1.6180339887498947 iterasi ke - 8 = 1.618033988749895 iterasi ke - 9 = 1.618033988749895 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Tugas 2"},{"location":"NewtonRapshon/#metode-newton-rapshon","text":"Metode Newtown Rapshon adalah pencarian root yang menggunakan pendekatan linier. Secara khusus, kami menebak solusi x_0 x_0 dari persamaan f(x)=0 f(x)=0 , menghitung perkiraan linier dari f(x) f(x) pada x_0 x_0 dan kemudian menemukan x x -intercept dari pendekatan linier .","title":"Metode Newton Rapshon"},{"location":"NewtonRapshon/#rumus","text":"Biarkan f(x) f(x) menjadi fungsi yang dapat dibedakan. Jika x_0 x_0 mendekati solusi f(x)=0 f(x)=0 maka kita dapat memperkirakan f(x) f(x) dengan garis singgung pada x_0 x_0 dan menghitung x x -terima dari garis singgung. Persamaan garis singgung pada x_0 x_0 adalah y=f\u2032(x_0)(x\u2212x_0)+f(x_0) y=f\u2032(x_0)(x\u2212x_0)+f(x_0) x x -intercept adalah solusi x_1 x_1 dari persamaan 0=f\u2032(x_0)(x_1\u2212x_0)+f(x_0) 0=f\u2032(x_0)(x_1\u2212x_0)+f(x_0) dan kami menyelesaikannya dengan x_1 x_1 x1=x0\u2212 \\frac{f(x_0)}{f\u2032(x_0)} x1=x0\u2212 \\frac{f(x_0)}{f\u2032(x_0)} Jika kami menerapkan prosedur ini berulang kali, maka kami memperoleh urutan yang diberikan oleh rumus rekursif xn+1=xn\u2212 \\frac{f(x_n)}{f\u2032(x_n)} xn+1=xn\u2212 \\frac{f(x_n)}{f\u2032(x_n)} yang (berpotensi) konvergen ke solusi persamaan f(x)=0 f(x)=0 .","title":"Rumus"},{"location":"NewtonRapshon/#menyusun-algoritma-dan-pemrograman-newton-rhapson","text":"dari rumus yang kita dapat diatas kita dapat menyusun sebuah algoritma yang nantinya akan dibuat menjadi sebuah program. Algoritma menyusun akar - akar f(x) = 0 f(x) = 0 sebagai berikut : Didefinisikan fungsi f f dengan f(x) f(x) dan f'(x) f'(x) Ditentukan Epsilon sebagai Toleransi kesalahan serta iterasi maksimum untuk Stopping Condition Dipilih tebakan awal x_0 x_0 Dihitung f(x_0) f(x_0) dan f'(x_0) f'(x_0) Dihitung x_b = x_0 - \\frac{f(x_0)}{f'(x_0)}f'(x_0) \\neq 0 x_b = x_0 - \\frac{f(x_0)}{f'(x_0)}f'(x_0) \\neq 0 . jika f'(x_0) = 0 f'(x_0) = 0 kembali ke langkah - 3 Jika \\left | x_b - x_0 \\right | < \\varepsilon \\left | x_b - x_0 \\right | < \\varepsilon . itersasi lebih dari iterasi maksimum tulis x_{hampiran} = x_b x_{hampiran} = x_b sebagai hasil hampiran akar; jika tidak, lanjutkan ke langkah berikutnya. Ganti nilai x_0 x_0 dengan x_0 = x_b x_0 = x_b dan kembali ke langkah-4","title":"Menyusun Algoritma dan Pemrograman Newton Rhapson"},{"location":"NewtonRapshon/#listing-program","text":"#Program python untuk memperkirakan akar polinomial #menggunakan metode newton-raphson import math #f(x) - fungsi polynomial def f ( x ): function = ( x ** 3 ) - ( 2 * x ) - 1 return function def derivative ( x ): #berfungsi untuk menemukan turunan dari polinomial h = 0.000001 derivative = ( f ( x + h ) - f ( x )) / h return derivative def newton_raphson ( x ): return ( x - ( f ( x ) / derivative ( x ))) # p - titik awal mis. nilai lebih dekat ke root # n - jmulah iterasi def iterate ( p , n ): print ( \"Banyak Iterasinya =\" , n ) x = p for i in range ( n ): x = newton_raphson ( x ) print ( \"iterasi ke-\" , i , \"=\" , x ) return ( \"\" ) print ( iterate ( 1 , 10 )) #cetakan akar polinomial x ^ 3 - 2x - 1 menggunakan 3 iterasi dan ambil titik awal sebagai 1 Output Banyak Iterasinya = 10 iterasi ke - 0 = 2.999994000093219 iterasi ke - 1 = 2.199996832141079 iterasi ke - 2 = 1.7808294919560141 iterasi ke - 3 = 1.6363030634057565 iterasi ke - 4 = 1.618304588651506 iterasi ke - 5 = 1.6180340496697716 iterasi ke - 6 = 1.6180339887499484 iterasi ke - 7 = 1.6180339887498947 iterasi ke - 8 = 1.618033988749895 iterasi ke - 9 = 1.618033988749895 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Listing Program"},{"location":"Tugas3/","text":"Eliminasi Gaus \u00b6 Eliminasi Gauss adalah prosedur pemecahan sistem persamaan linear dengan mengubahnya menjadi bentuk matriks eselon baris tereduksi dengan Operasi Baris Elementer. Matriks Eselon Baris Tereduksi adalah sebuah bentuk matriks eselon baris yang lebih disederhanakan yang bertujuan agar lebih mudah dalam pencarian pemecahan (solusi) dari suatu sistem persamaan. Cara penyelesaian dengan menggunakan metode eliminasi Gauss dijabarkan dalam tabel berikut: Listing Program import numpy as np #Membuat Matrix A = [] B = [] n = int ( input ( \"Tentukan ordo Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan elemen Matrix: \" )) baris . append ( a ) A . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) B . append ( h ) Matrix = np . array ( A , float ) Hasil = np . array ( B , float ) n = len ( Matrix ) #Eliminasi Gauss for k in range ( 0 , n - 1 ): for i in range ( k + 1 , n ): if Matrix [ i , k ] != 0 : lam = Matrix [ i , k ] / Matrix [ k , k ] Matrix [ i , k : n ] = Matrix [ i , k : n ] - ( Matrix [ k , k : n ] * lam ) Hasil [ i ] = Hasil [ i ] - ( Hasil [ k ] * lam ) print ( \"Matrix A : \" , ' \\n ' , Matrix ) #Substitusi x = np . zeros ( n , float ) for m in range ( n - 1 , - 1 , - 1 ): x [ m ] = ( Hasil [ m ] - np . dot ( Matrix [ m , m + 1 : n ], x [ m + 1 : n ])) / Matrix [ m , m ] print ( 'Nilai X ' , m + 1 , '=' , x [ m ]) Output Tentukan ordo Matrix : 3 Masukkan elemen Matrix : 2 Masukkan elemen Matrix : 1 Masukkan elemen Matrix : - 1 Masukkan elemen Matrix : - 3 Masukkan elemen Matrix : - 1 Masukkan elemen Matrix : 2 Masukkan elemen Matrix : - 2 Masukkan elemen Matrix : 1 Masukkan elemen Matrix : 2 Masukkan Hasil : 8 Masukkan Hasil : - 11 Masukkan Hasil : - 3 Matrix A : [[ 2. 1. - 1. ] [ 0. 0.5 0.5 ] [ 0. 0. - 1. ]] Nilai X 3 = - 1.0 Nilai X 2 = 3.0 Nilai X 1 = 2.0 Eliminasi Gaus Jacobi \u00b6 Metode Jacobi, adalah metode tak langsung atau metode iteratif yang melakuakn perbaharuan nilai x yang diperoleh tiap iterasi (mirip metode substitusi berurutan). Metode ini hampir sama dengan metode Gauss Seidel, namun tidak melibatkan perhitungan implisit. Metode Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan persamaan linier berukuran besar dan proporsi koefisien nolnya besar. Metode ini merupakan suatu teknik penyelesaian SPL berukuran n x n, AX = b, secara iteratif. Proses penyelesaian dimulai dengan suatu hampiran awal terhadap penyelesaian, X_0 X_0 , kemudian membentuk suatu serangkaian vector X_1 X_1 , X_2 X_2 , \u2026 yang konvergen ke X. Listing Program from pprint import pprint from numpy import array , zeros , diag , diagflat , dot import numpy as np def jacobi ( A , b , N = 25 , x = None ): #Membuat iniial guess if x is None : x = zeros ( len ( A [ 0 ])) #Membuat vektor dari elemen matrix A D = diag ( A ) R = A - diagflat ( D ) #Iterasi for i in range ( N ): x = ( b - dot ( R , x )) / D return x Mat1 = [] Mat2 = [] n = int ( input ( \"Masukkan Ordo Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan elemen: \" )) baris . append ( a ) Mat1 . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) Mat2 . append ( h ) A = array ( Mat1 , float ) b = array ( Mat2 , float ) x = len ( Mat1 ) guess = np . zeros ( x , float ) sol = jacobi ( A , b , N = 25 , x = guess ) print ( \"A:\" ) pprint ( A ) print ( \"b:\" ) pprint ( b ) print ( \"x:\" ) pprint ( sol ) Output Masukkan Ordo Matrix : 3 Masukkan elemen : 2 Masukkan elemen : 1 Masukkan elemen : - 1 Masukkan elemen : - 3 Masukkan elemen : - 1 Masukkan elemen : 2 Masukkan elemen : - 2 Masukkan elemen : 1 Masukkan elemen : 2 Masukkan Hasil : 8 Masukkan Hasil : - 11 Masukkan Hasil : - 3 A : array ([[ 2. , 1. , - 1. ], [ - 3. , - 1. , 2. ], [ - 2. , 1. , 2. ]]) b : array ([ 8. , - 11. , - 3. ]) x : array ([ 34.89370728 , 81.70007324 , 4.78002167 ]) Eliminasi Gaus Seidel \u00b6 Metode Gauss-Seidel digunakan untuk menyelesaikan sistem persamaan linear (SPL) berukuran besar dan proporsi koefisien nolnya besar, seperti sistem-sistem yang banyak ditemukan dalam sistem persamaan diferensial. Metode iterasi Gauss-Seidel dikembangkan dari gagasan metode iterasi pada solusi persamaan tak linier. Teknik iterasi jarang digunakan untuk menyelesaikan SPL berukuran kecil karena metode-metode langsung seperti metode eliminasi Gauss lebih efisien daripada metode iteratif. Akan tetapi, untuk SPL berukuran besar dengan persentase elemen nol pada matriks koefisien besar, teknik iterasi lebih efisien daripada metode langsung dalam hal penggunaan memori komputer maupun waktu komputasi. Dengan metode iterasi Gauss-Seidel sesatan pembulatan dapat diperkecil karena dapat meneruskan iterasi sampai solusinya seteliti mungkin sesuai dengan batas sesatan yang diperbolehkan. Listing Program def seidel ( a , x , b ): #Mencari Panjang Matrix n = len ( a ) for j in range ( 0 , n ): d = b [ j ] #Menghitung xi, yi, zi for i in range ( 0 , n ): if ( j != i ): d -= a [ j ][ i ] * x [ i ] x [ j ] = d / a [ j ][ j ] #Solusi return x m = int ( input ( \"Masukkan Panjang Matrix: \" )) a = [] b = [] for k in range ( m ): mat1 = [] for i in range ( m ): l = float ( input ( \"Masukkan a\" + str ( k + 1 ) + \",\" + str ( i + 1 ) + \": \" )) mat1 . append ( l ) h = float ( input ( \"Masukkan Hasil: \" )) b . append ( h ) a . append ( mat1 ) n = 3 x = [ 0 , 0 , 0 ] print ( x ) for i in range ( 0 , 100 ): x = seidel ( a , x , b ) print ( x ) Output Masukkan Panjang Matrix : 3 Masukkan a1 , 1 : 4 Masukkan a1 , 2 : - 1 Masukkan a1 , 3 : 1 Masukkan Hasil : 7 Masukkan a2 , 1 : 4 Masukkan a2 , 2 : - 8 Masukkan a2 , 3 : 1 Masukkan Hasil : - 21 Masukkan a3 , 1 : - 2 Masukkan a3 , 2 : 1 Masukkan a3 , 3 : 5 Masukkan Hasil : - 15 [ 0 , 0 , 0 ] [ 1.75 , 3.5 , - 3.0 ] [ 3.375 , 3.9375 , - 2.4375 ] [ 3.34375 , 3.9921875 , - 2.4609375 ] [ 3.36328125 , 3.9990234375 , - 2.4544921875 ] [ 3.36337890625 , 3.9998779296875 , - 2.4546240234375 ] [ 3.36362548828125 , 3.999984741210938 , - 2.4545467529296876 ] [ 3.363632873535156 , 3.999998092651367 , - 2.454546469116211 ] [ 3.3636361404418946 , 3.999999761581421 , - 2.4545454961395263 ] [ 3.363636314430237 , 3.999999970197678 , - 2.454545468267441 ] [ 3.3636363596162795 , 3.9999999962747097 , - 2.45454545540843 ] [ 3.363636362920785 , 3.9999999995343387 , - 2.454545454738554 ] [ 3.363636363568223 , 3.999999999941792 , - 2.454545454561069 ] [ 3.3636363636257154 , 3.999999999992724 , - 2.4545454545482586 ] [ 3.3636363636352455 , 3.9999999999990905 , - 2.4545454545457197 ] [ 3.3636363636362026 , 3.9999999999998868 , - 2.4545454545454963 ] [ 3.3636363636363455 , 3.999999999999986 , - 2.454545454545459 ] [ 3.363636363636361 , 3.9999999999999982 , - 2.454545454545455 ] [ 3.3636363636363633 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] Masukkan Panjang Matrix : 3 Masukkan a1 , 1 : 4 Masukkan a1 , 2 : - 1 Masukkan a1 , 3 : 1 Masukkan Hasil : 7 Masukkan a2 , 1 : 4 Masukkan a2 , 2 : - 8 Masukkan a2 , 3 : 1 Masukkan Hasil : - 21 Masukkan a3 , 1 : - 2 Masukkan a3 , 2 : 1 Masukkan a3 , 3 : 5 Masukkan Hasil : 15 [ 0 , 0 , 0 ] [ 1.75 , 3.5 , 3.0 ] [ 1.875 , 3.9375 , 2.9625 ] [ 1.99375 , 3.9921875 , 2.9990625 ] [ 1.99828125 , 3.9990234375 , 2.9995078125 ] [ 1.99987890625 , 3.9998779296875 , 2.9999759765625003 ] [ 1.99997548828125 , 3.9999847412109375 , 2.999993247070312 ] [ 1.9999978735351562 , 3.9999980926513667 , 2.999999530883789 ] [ 1.9999996404418945 , 3.9999997615814205 , 2.9999999038604734 ] [ 1.9999999644302369 , 3.9999999701976776 , 2.9999999917325595 ] [ 1.9999999946162794 , 3.9999999962747097 , 2.99999999859157 ] [ 1.9999999994207849 , 3.9999999995343387 , 2.9999999998614464 ] [ 1.9999999999182232 , 3.999999999941793 , 2.999999999978931 ] [ 1.9999999999907154 , 3.999999999992724 , 2.9999999999977414 ] [ 1.9999999999987457 , 3.9999999999990905 , 2.9999999999996803 ] [ 1.9999999999998526 , 3.9999999999998863 , 2.9999999999999636 ] [ 1.9999999999999807 , 3.999999999999986 , 2.999999999999995 ] [ 1.9999999999999978 , 3.9999999999999987 , 2.9999999999999996 ] [ 1.9999999999999996 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Tugas 3"},{"location":"Tugas3/#eliminasi-gaus","text":"Eliminasi Gauss adalah prosedur pemecahan sistem persamaan linear dengan mengubahnya menjadi bentuk matriks eselon baris tereduksi dengan Operasi Baris Elementer. Matriks Eselon Baris Tereduksi adalah sebuah bentuk matriks eselon baris yang lebih disederhanakan yang bertujuan agar lebih mudah dalam pencarian pemecahan (solusi) dari suatu sistem persamaan. Cara penyelesaian dengan menggunakan metode eliminasi Gauss dijabarkan dalam tabel berikut: Listing Program import numpy as np #Membuat Matrix A = [] B = [] n = int ( input ( \"Tentukan ordo Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan elemen Matrix: \" )) baris . append ( a ) A . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) B . append ( h ) Matrix = np . array ( A , float ) Hasil = np . array ( B , float ) n = len ( Matrix ) #Eliminasi Gauss for k in range ( 0 , n - 1 ): for i in range ( k + 1 , n ): if Matrix [ i , k ] != 0 : lam = Matrix [ i , k ] / Matrix [ k , k ] Matrix [ i , k : n ] = Matrix [ i , k : n ] - ( Matrix [ k , k : n ] * lam ) Hasil [ i ] = Hasil [ i ] - ( Hasil [ k ] * lam ) print ( \"Matrix A : \" , ' \\n ' , Matrix ) #Substitusi x = np . zeros ( n , float ) for m in range ( n - 1 , - 1 , - 1 ): x [ m ] = ( Hasil [ m ] - np . dot ( Matrix [ m , m + 1 : n ], x [ m + 1 : n ])) / Matrix [ m , m ] print ( 'Nilai X ' , m + 1 , '=' , x [ m ]) Output Tentukan ordo Matrix : 3 Masukkan elemen Matrix : 2 Masukkan elemen Matrix : 1 Masukkan elemen Matrix : - 1 Masukkan elemen Matrix : - 3 Masukkan elemen Matrix : - 1 Masukkan elemen Matrix : 2 Masukkan elemen Matrix : - 2 Masukkan elemen Matrix : 1 Masukkan elemen Matrix : 2 Masukkan Hasil : 8 Masukkan Hasil : - 11 Masukkan Hasil : - 3 Matrix A : [[ 2. 1. - 1. ] [ 0. 0.5 0.5 ] [ 0. 0. - 1. ]] Nilai X 3 = - 1.0 Nilai X 2 = 3.0 Nilai X 1 = 2.0","title":"Eliminasi Gaus"},{"location":"Tugas3/#eliminasi-gaus-jacobi","text":"Metode Jacobi, adalah metode tak langsung atau metode iteratif yang melakuakn perbaharuan nilai x yang diperoleh tiap iterasi (mirip metode substitusi berurutan). Metode ini hampir sama dengan metode Gauss Seidel, namun tidak melibatkan perhitungan implisit. Metode Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan persamaan linier berukuran besar dan proporsi koefisien nolnya besar. Metode ini merupakan suatu teknik penyelesaian SPL berukuran n x n, AX = b, secara iteratif. Proses penyelesaian dimulai dengan suatu hampiran awal terhadap penyelesaian, X_0 X_0 , kemudian membentuk suatu serangkaian vector X_1 X_1 , X_2 X_2 , \u2026 yang konvergen ke X. Listing Program from pprint import pprint from numpy import array , zeros , diag , diagflat , dot import numpy as np def jacobi ( A , b , N = 25 , x = None ): #Membuat iniial guess if x is None : x = zeros ( len ( A [ 0 ])) #Membuat vektor dari elemen matrix A D = diag ( A ) R = A - diagflat ( D ) #Iterasi for i in range ( N ): x = ( b - dot ( R , x )) / D return x Mat1 = [] Mat2 = [] n = int ( input ( \"Masukkan Ordo Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan elemen: \" )) baris . append ( a ) Mat1 . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) Mat2 . append ( h ) A = array ( Mat1 , float ) b = array ( Mat2 , float ) x = len ( Mat1 ) guess = np . zeros ( x , float ) sol = jacobi ( A , b , N = 25 , x = guess ) print ( \"A:\" ) pprint ( A ) print ( \"b:\" ) pprint ( b ) print ( \"x:\" ) pprint ( sol ) Output Masukkan Ordo Matrix : 3 Masukkan elemen : 2 Masukkan elemen : 1 Masukkan elemen : - 1 Masukkan elemen : - 3 Masukkan elemen : - 1 Masukkan elemen : 2 Masukkan elemen : - 2 Masukkan elemen : 1 Masukkan elemen : 2 Masukkan Hasil : 8 Masukkan Hasil : - 11 Masukkan Hasil : - 3 A : array ([[ 2. , 1. , - 1. ], [ - 3. , - 1. , 2. ], [ - 2. , 1. , 2. ]]) b : array ([ 8. , - 11. , - 3. ]) x : array ([ 34.89370728 , 81.70007324 , 4.78002167 ])","title":"Eliminasi Gaus Jacobi"},{"location":"Tugas3/#eliminasi-gaus-seidel","text":"Metode Gauss-Seidel digunakan untuk menyelesaikan sistem persamaan linear (SPL) berukuran besar dan proporsi koefisien nolnya besar, seperti sistem-sistem yang banyak ditemukan dalam sistem persamaan diferensial. Metode iterasi Gauss-Seidel dikembangkan dari gagasan metode iterasi pada solusi persamaan tak linier. Teknik iterasi jarang digunakan untuk menyelesaikan SPL berukuran kecil karena metode-metode langsung seperti metode eliminasi Gauss lebih efisien daripada metode iteratif. Akan tetapi, untuk SPL berukuran besar dengan persentase elemen nol pada matriks koefisien besar, teknik iterasi lebih efisien daripada metode langsung dalam hal penggunaan memori komputer maupun waktu komputasi. Dengan metode iterasi Gauss-Seidel sesatan pembulatan dapat diperkecil karena dapat meneruskan iterasi sampai solusinya seteliti mungkin sesuai dengan batas sesatan yang diperbolehkan. Listing Program def seidel ( a , x , b ): #Mencari Panjang Matrix n = len ( a ) for j in range ( 0 , n ): d = b [ j ] #Menghitung xi, yi, zi for i in range ( 0 , n ): if ( j != i ): d -= a [ j ][ i ] * x [ i ] x [ j ] = d / a [ j ][ j ] #Solusi return x m = int ( input ( \"Masukkan Panjang Matrix: \" )) a = [] b = [] for k in range ( m ): mat1 = [] for i in range ( m ): l = float ( input ( \"Masukkan a\" + str ( k + 1 ) + \",\" + str ( i + 1 ) + \": \" )) mat1 . append ( l ) h = float ( input ( \"Masukkan Hasil: \" )) b . append ( h ) a . append ( mat1 ) n = 3 x = [ 0 , 0 , 0 ] print ( x ) for i in range ( 0 , 100 ): x = seidel ( a , x , b ) print ( x ) Output Masukkan Panjang Matrix : 3 Masukkan a1 , 1 : 4 Masukkan a1 , 2 : - 1 Masukkan a1 , 3 : 1 Masukkan Hasil : 7 Masukkan a2 , 1 : 4 Masukkan a2 , 2 : - 8 Masukkan a2 , 3 : 1 Masukkan Hasil : - 21 Masukkan a3 , 1 : - 2 Masukkan a3 , 2 : 1 Masukkan a3 , 3 : 5 Masukkan Hasil : - 15 [ 0 , 0 , 0 ] [ 1.75 , 3.5 , - 3.0 ] [ 3.375 , 3.9375 , - 2.4375 ] [ 3.34375 , 3.9921875 , - 2.4609375 ] [ 3.36328125 , 3.9990234375 , - 2.4544921875 ] [ 3.36337890625 , 3.9998779296875 , - 2.4546240234375 ] [ 3.36362548828125 , 3.999984741210938 , - 2.4545467529296876 ] [ 3.363632873535156 , 3.999998092651367 , - 2.454546469116211 ] [ 3.3636361404418946 , 3.999999761581421 , - 2.4545454961395263 ] [ 3.363636314430237 , 3.999999970197678 , - 2.454545468267441 ] [ 3.3636363596162795 , 3.9999999962747097 , - 2.45454545540843 ] [ 3.363636362920785 , 3.9999999995343387 , - 2.454545454738554 ] [ 3.363636363568223 , 3.999999999941792 , - 2.454545454561069 ] [ 3.3636363636257154 , 3.999999999992724 , - 2.4545454545482586 ] [ 3.3636363636352455 , 3.9999999999990905 , - 2.4545454545457197 ] [ 3.3636363636362026 , 3.9999999999998868 , - 2.4545454545454963 ] [ 3.3636363636363455 , 3.999999999999986 , - 2.454545454545459 ] [ 3.363636363636361 , 3.9999999999999982 , - 2.454545454545455 ] [ 3.3636363636363633 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] Masukkan Panjang Matrix : 3 Masukkan a1 , 1 : 4 Masukkan a1 , 2 : - 1 Masukkan a1 , 3 : 1 Masukkan Hasil : 7 Masukkan a2 , 1 : 4 Masukkan a2 , 2 : - 8 Masukkan a2 , 3 : 1 Masukkan Hasil : - 21 Masukkan a3 , 1 : - 2 Masukkan a3 , 2 : 1 Masukkan a3 , 3 : 5 Masukkan Hasil : 15 [ 0 , 0 , 0 ] [ 1.75 , 3.5 , 3.0 ] [ 1.875 , 3.9375 , 2.9625 ] [ 1.99375 , 3.9921875 , 2.9990625 ] [ 1.99828125 , 3.9990234375 , 2.9995078125 ] [ 1.99987890625 , 3.9998779296875 , 2.9999759765625003 ] [ 1.99997548828125 , 3.9999847412109375 , 2.999993247070312 ] [ 1.9999978735351562 , 3.9999980926513667 , 2.999999530883789 ] [ 1.9999996404418945 , 3.9999997615814205 , 2.9999999038604734 ] [ 1.9999999644302369 , 3.9999999701976776 , 2.9999999917325595 ] [ 1.9999999946162794 , 3.9999999962747097 , 2.99999999859157 ] [ 1.9999999994207849 , 3.9999999995343387 , 2.9999999998614464 ] [ 1.9999999999182232 , 3.999999999941793 , 2.999999999978931 ] [ 1.9999999999907154 , 3.999999999992724 , 2.9999999999977414 ] [ 1.9999999999987457 , 3.9999999999990905 , 2.9999999999996803 ] [ 1.9999999999998526 , 3.9999999999998863 , 2.9999999999999636 ] [ 1.9999999999999807 , 3.999999999999986 , 2.999999999999995 ] [ 1.9999999999999978 , 3.9999999999999987 , 2.9999999999999996 ] [ 1.9999999999999996 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Eliminasi Gaus Seidel"},{"location":"Tugas4/","text":"Metode Trapezoid Recursive \u00b6 Aturan Trapesium merupakan suatu metode pengintegralan dalam analisis numerik.di dalam Kalkulus, integral tentu didefinisikan sebagai sebuah limit Riemann Teorema Dasar Kalkulus integral tersebut dapat dihitung dengan rumus, \\int_a^bf(x)\\,dx=F(b)-F(a) \\int_a^bf(x)\\,dx=F(b)-F(a) Dengan F(x) F(x) adalah f(x) f(x) (yakni F\u2019(x)=f(x) F\u2019(x)=f(x) ). Banyak integral tentu yang dapat dihitung dengan rumus tesebut, namun demikian, tidak sedikit integral yang tidak dapat dihitung dengan rumus di atas, hal itu dikarenakan integral f(x) f(x) tidak mempunyai antiderivatif yang dapat dinyatakan dalam fungsi-fungsi elementer. Dalam hal ini perhitungan yang dapat dilakukan adalah secara numerik. Integrasi numerik merupakan suatu alat utama yang digunakan para ilmuwan untuk mendapatkan nilai-nilai hampiran untuk integral tentu yang tidak dapat diselesaikan secara analitik. Dalam mendapatkan nilai-nilai hampiran integral tentu, digunakan banyak metode, salah satu metode yang dapat digunakan adalah Aturan Trapesium Rekursif. Berikut akan dijelaskan penghitungan integral tentu menggunakan Aturan Trapesium Rekursif. Aturan Trapezoid Recursive Misalkan f f adalah suatu fungsi yang terdefinisi pada [a,b] [a,b] . Misalkan a=x_0<x_1<x_2<...<x_n a=x_0<x_1<x_2<...<x_n suatu partisi sedemikian seihngga x_k=x_0+kh x_k=x_0+kh dengan h=(b-a)/n h=(b-a)/n untuk k=0,1,2,3,...n k=0,1,2,3,...n Perhatikan aturan trapesium untuk fungsi f f terhadap partisi di atas. $T_n(f,h) =\\frac{h}{2}(f_0 + 2f_1 + 2f_2 + ... + 2f_{n-1} + f_n) $ \u200b = \\frac{h}{2}{(f_0 + f_n) + h(f_1 + f_2 + ... + 2f_{n-1}}) = \\frac{h}{2}{(f_0 + f_n) + h(f_1 + f_2 + ... + 2f_{n-1}}) \u200b = \\frac{h}{2}(f_0 + f_n) + h \\sum^{n-1}_{k=1}f_k. = \\frac{h}{2}(f_0 + f_n) + h \\sum^{n-1}_{k=1}f_k. Sekarang jika lebar setiap subinterval diperkecil separuhnya maka dengan T_0 = T_1(f,h) = \\frac{h}{2}(f(a)+f(b)) T_0 = T_1(f,h) = \\frac{h}{2}(f(a)+f(b)) dan T_k = T_{2^k}(f, \\frac{h}{2^k}), k = 1,2,3, ... T_k = T_{2^k}(f, \\frac{h}{2^k}), k = 1,2,3, ... Barisan aturan trapesium tersebut memenuhi hubungan T_{k+1} = \\frac{T_k}{2} + \\frac{h}{2^{k+1}} \\sum^{2^k}_{j=1}f_{2j-1}, T_{k+1} = \\frac{T_k}{2} + \\frac{h}{2^{k+1}} \\sum^{2^k}_{j=1}f_{2j-1}, dengan $f_i = f(a+ i\\frac{h}{2^{k+1}}) $ Dalam menghitung hampiran $\\int_a^b f(x) dx $ dengan aturan trapezoid recursive, kita lakukan langkah-langkah berikut: h = b-a h = b-a T_0 = \\frac{h}{2}(f(a)) + (b)) T_0 = \\frac{h}{2}(f(a)) + (b)) T1 = \\frac{T_0}{2} + \\frac{h}{4} f_1 T1 = \\frac{T_0}{2} + \\frac{h}{4} f_1 T_2 = \\frac{T_1}{2} + \\frac{h}{8}(f_1 + f_3) T_2 = \\frac{T_1}{2} + \\frac{h}{8}(f_1 + f_3) T_3 = \\frac{T_2}{2} + \\frac{h}{16}(f_1+f_3+f_5)... T_3 = \\frac{T_2}{2} + \\frac{h}{16}(f_1+f_3+f_5)... Listing Program #mendefinisikan fungsi def fungsi ( x ): y = 1 / ( 1 + x ) return y print ( \" \" ) print ( \"Rumus yang digunakan adalah = f(x) = 1/(1+x)\" ) print ( \" \" ) a = float ( input ( \"Masukkan batas bawah (a) = \" )) b = float ( input ( \"Masukkan batas atas (b) = \" )) c = int ( input ( \"Masukkan banyak iterasi (n) =\" )) error = [] print ( \" \" ) print ( \"<<-------------Hasil penghitungan----------------->>\" ) print ( \"banyak iterasi\" , \" \\t \" , \"n\" , \" \\t\\t \" , \"Nilai Trapezoid\" ) for iterasi in range ( 0 , c ): n = 2 ** iterasi h = ( b - a ) / n xi = a y = 0 for i in range ( 1 , n ): xi = xi + h y += fungsi ( xi ) trapezoid = (( h ) * ( fungsi ( a ) + ( 2 * y ) + fungsi ( b ))) / 2 error . append ( trapezoid ) print ( iterasi + 1 , \" \\t\\t \" , n , \" \\t\\t \" , trapezoid ) print ( error [ iterasi - 1 ]) print ( error [ iterasi ]) hasil = ( error [ iterasi - 1 ] - error [ iterasi ]) print ( \"estimasi error =\" , hasil ) Ouput C : \\ Users \\ User \\ AppData \\ Local \\ Programs \\ Python \\ Python37 \\ python . exe \"D:/Tugas Kuliah/Semester 4/Komnum/trapezoid.py\" Rumus yang digunakan adalah = f ( x ) = 1 / ( 1 + x ) Masukkan batas bawah ( a ) = 8 Masukkan batas atas ( b ) = 10 Masukkan banyak iterasi ( n ) = 10 <<------------- Hasil penghitungan ----------------->> banyak iterasi n Nilai Trapezoid 1 1 0.20202020202020202 2 2 0.20101010101010103 3 4 0.20075567707146655 4 8 0.20069194905971333 5 16 0.20067600937463678 6 32 0.200672023972355 7 64 0.20067102759170743 8 128 0.2006707784946655 9 256 0.20067071622028754 10 512 0.20067070065168577 0.20067071622028754 0.20067070065168577 estimasi error = 1.556860176887831e-08 Process finished with exit code 0 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Tugas 4"},{"location":"Tugas4/#metode-trapezoid-recursive","text":"Aturan Trapesium merupakan suatu metode pengintegralan dalam analisis numerik.di dalam Kalkulus, integral tentu didefinisikan sebagai sebuah limit Riemann Teorema Dasar Kalkulus integral tersebut dapat dihitung dengan rumus, \\int_a^bf(x)\\,dx=F(b)-F(a) \\int_a^bf(x)\\,dx=F(b)-F(a) Dengan F(x) F(x) adalah f(x) f(x) (yakni F\u2019(x)=f(x) F\u2019(x)=f(x) ). Banyak integral tentu yang dapat dihitung dengan rumus tesebut, namun demikian, tidak sedikit integral yang tidak dapat dihitung dengan rumus di atas, hal itu dikarenakan integral f(x) f(x) tidak mempunyai antiderivatif yang dapat dinyatakan dalam fungsi-fungsi elementer. Dalam hal ini perhitungan yang dapat dilakukan adalah secara numerik. Integrasi numerik merupakan suatu alat utama yang digunakan para ilmuwan untuk mendapatkan nilai-nilai hampiran untuk integral tentu yang tidak dapat diselesaikan secara analitik. Dalam mendapatkan nilai-nilai hampiran integral tentu, digunakan banyak metode, salah satu metode yang dapat digunakan adalah Aturan Trapesium Rekursif. Berikut akan dijelaskan penghitungan integral tentu menggunakan Aturan Trapesium Rekursif. Aturan Trapezoid Recursive Misalkan f f adalah suatu fungsi yang terdefinisi pada [a,b] [a,b] . Misalkan a=x_0<x_1<x_2<...<x_n a=x_0<x_1<x_2<...<x_n suatu partisi sedemikian seihngga x_k=x_0+kh x_k=x_0+kh dengan h=(b-a)/n h=(b-a)/n untuk k=0,1,2,3,...n k=0,1,2,3,...n Perhatikan aturan trapesium untuk fungsi f f terhadap partisi di atas. $T_n(f,h) =\\frac{h}{2}(f_0 + 2f_1 + 2f_2 + ... + 2f_{n-1} + f_n) $ \u200b = \\frac{h}{2}{(f_0 + f_n) + h(f_1 + f_2 + ... + 2f_{n-1}}) = \\frac{h}{2}{(f_0 + f_n) + h(f_1 + f_2 + ... + 2f_{n-1}}) \u200b = \\frac{h}{2}(f_0 + f_n) + h \\sum^{n-1}_{k=1}f_k. = \\frac{h}{2}(f_0 + f_n) + h \\sum^{n-1}_{k=1}f_k. Sekarang jika lebar setiap subinterval diperkecil separuhnya maka dengan T_0 = T_1(f,h) = \\frac{h}{2}(f(a)+f(b)) T_0 = T_1(f,h) = \\frac{h}{2}(f(a)+f(b)) dan T_k = T_{2^k}(f, \\frac{h}{2^k}), k = 1,2,3, ... T_k = T_{2^k}(f, \\frac{h}{2^k}), k = 1,2,3, ... Barisan aturan trapesium tersebut memenuhi hubungan T_{k+1} = \\frac{T_k}{2} + \\frac{h}{2^{k+1}} \\sum^{2^k}_{j=1}f_{2j-1}, T_{k+1} = \\frac{T_k}{2} + \\frac{h}{2^{k+1}} \\sum^{2^k}_{j=1}f_{2j-1}, dengan $f_i = f(a+ i\\frac{h}{2^{k+1}}) $ Dalam menghitung hampiran $\\int_a^b f(x) dx $ dengan aturan trapezoid recursive, kita lakukan langkah-langkah berikut: h = b-a h = b-a T_0 = \\frac{h}{2}(f(a)) + (b)) T_0 = \\frac{h}{2}(f(a)) + (b)) T1 = \\frac{T_0}{2} + \\frac{h}{4} f_1 T1 = \\frac{T_0}{2} + \\frac{h}{4} f_1 T_2 = \\frac{T_1}{2} + \\frac{h}{8}(f_1 + f_3) T_2 = \\frac{T_1}{2} + \\frac{h}{8}(f_1 + f_3) T_3 = \\frac{T_2}{2} + \\frac{h}{16}(f_1+f_3+f_5)... T_3 = \\frac{T_2}{2} + \\frac{h}{16}(f_1+f_3+f_5)... Listing Program #mendefinisikan fungsi def fungsi ( x ): y = 1 / ( 1 + x ) return y print ( \" \" ) print ( \"Rumus yang digunakan adalah = f(x) = 1/(1+x)\" ) print ( \" \" ) a = float ( input ( \"Masukkan batas bawah (a) = \" )) b = float ( input ( \"Masukkan batas atas (b) = \" )) c = int ( input ( \"Masukkan banyak iterasi (n) =\" )) error = [] print ( \" \" ) print ( \"<<-------------Hasil penghitungan----------------->>\" ) print ( \"banyak iterasi\" , \" \\t \" , \"n\" , \" \\t\\t \" , \"Nilai Trapezoid\" ) for iterasi in range ( 0 , c ): n = 2 ** iterasi h = ( b - a ) / n xi = a y = 0 for i in range ( 1 , n ): xi = xi + h y += fungsi ( xi ) trapezoid = (( h ) * ( fungsi ( a ) + ( 2 * y ) + fungsi ( b ))) / 2 error . append ( trapezoid ) print ( iterasi + 1 , \" \\t\\t \" , n , \" \\t\\t \" , trapezoid ) print ( error [ iterasi - 1 ]) print ( error [ iterasi ]) hasil = ( error [ iterasi - 1 ] - error [ iterasi ]) print ( \"estimasi error =\" , hasil ) Ouput C : \\ Users \\ User \\ AppData \\ Local \\ Programs \\ Python \\ Python37 \\ python . exe \"D:/Tugas Kuliah/Semester 4/Komnum/trapezoid.py\" Rumus yang digunakan adalah = f ( x ) = 1 / ( 1 + x ) Masukkan batas bawah ( a ) = 8 Masukkan batas atas ( b ) = 10 Masukkan banyak iterasi ( n ) = 10 <<------------- Hasil penghitungan ----------------->> banyak iterasi n Nilai Trapezoid 1 1 0.20202020202020202 2 2 0.20101010101010103 3 4 0.20075567707146655 4 8 0.20069194905971333 5 16 0.20067600937463678 6 32 0.200672023972355 7 64 0.20067102759170743 8 128 0.2006707784946655 9 256 0.20067071622028754 10 512 0.20067070065168577 0.20067071622028754 0.20067070065168577 estimasi error = 1.556860176887831e-08 Process finished with exit code 0 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Metode Trapezoid Recursive"}]}